var documenterSearchIndex = {"docs":
[{"location":"api/high-level/#High-Level-Functions","page":"High-Level Functions","title":"High-Level Functions","text":"","category":"section"},{"location":"api/high-level/","page":"High-Level Functions","title":"High-Level Functions","text":"Pages = [\"high-level.md\"]","category":"page"},{"location":"api/high-level/","page":"High-Level Functions","title":"High-Level Functions","text":"solve\nsolve_extensive","category":"page"},{"location":"api/high-level/#ProgressiveHedging.solve","page":"High-Level Functions","title":"ProgressiveHedging.solve","text":"solve(tree::ScenarioTree,\n      subproblem_constructor::Function,\n      r<:Real,\n      other_args...;\n      max_iter::Int=1000,\n      atol::Float64=1e-6,\n      rtol::Float64=1e-6,\n      gap_tol::Float64=-1.0,\n      lower_bound::Int=0,\n      report::Int=0,\n      save_iterates::Int=0,\n      save_residuals::Bool=false,\n      timing::Bool=true,\n      warm_start::Bool=false,\n      callbacks::Vector{Callback}=Vector{Callback}(),\n      worker_assignments::Dict{Int,Set{ScenarioID}}=Dict{Int,Set{ScenarioID}}(),\n      args::Tuple=(),\n      kwargs...)\n\nSolve the stochastic programming problem described by tree and the models created by subproblem_constructor using Progressive Hedging.\n\nArguments\n\ntree::ScenararioTree : Scenario tree describing the structure of the problem to be solved.\nsubproblem_constructor::Function : User created function to construct a subproblem. Should accept a ScenarioID (a unique identifier for each scenario subproblem) as an argument and returns a subtype of AbstractSubproblem.\nr<:AbstractPenaltyParameter : PH penalty parameter\nother_args : Other arguments that should be passed to subproblem_constructor. See also keyword arguments args and kwargs.\n\nKeyword Arguments\n\nmax_iter::Int : Maximum number of iterations to perform before returning. Defaults to 1000.\natol::Float64 : Absolute error tolerance. Defaults to 1e-6.\nrtol::Float64 : Relative error tolerance. Defaults to 1e-6.\ngap_tol::Float64 : Relative gap tolerance. Terminate when the relative gap between the lower bound and objective are smaller than gap_tol. Any value < 0.0 disables this termination condition. Defaults to -1.0. See also the lower_bound keyword argument.\nlower_bound::Int : Compute and save a lower-bound using (Gade, et. al. 2016) every lower_bound iterations. Any value <= 0 disables lower-bound computation. Defaults to 0.\nreport::Int : Print progress to screen every report iterations. Any value <= 0 disables printing. Defaults to 0.\nsave_iterates::Int : Save PH iterates every save_iterates steps. Any value <= 0 disables saving iterates. Defaults to 0.\nsave_residuals::Int : Save PH residuals every save_residuals steps. Any value <= 0 disables saving residuals. Defaults to 0.\ntiming::Bool : Print timing info after solving if true. Defaults to true.\nwarm_start::Bool : Flag indicating that solver should be \"warm started\" by using the previous solution as the starting point (not compatible with all solvers)\ncallbacks::Vector{Callback} : Collection of Callback structs to call after each PH iteration. Callbacks will be executed in the order they appear. See Callback struct for more info. Defaults to empty vector.\nsubproblem_callbacks::Vector{SubproblemCallback} : Collection of SubproblemCallback structs to call before solving each subproblem. Each callback is called on each subproblem but does not affect other subproblems. See SubproblemCallback struct for more info. Defaults to empty vector.\nworker_assignments::Dict{Int,Set{ScenarioID}} : Dictionary specifying which scenario subproblems a worker will create and solve. The key values are worker ids as given by Distributed (see Distributed.workers()). The user is responsible for ensuring the specified workers exist and that every scenario is assigned to a worker. If no dictionary is given, scenarios are assigned to workers in round robin fashion. Defaults to empty dictionary.\nargs::Tuple : Tuple of arguments to pass to model_cosntructor. Defaults to (). See also other_args and kwargs.\nkwargs : Any keyword arguments not specified here that need to be passed to subproblem_constructor.  See also other_args and args.\n\n\n\n\n\n","category":"function"},{"location":"api/high-level/#ProgressiveHedging.solve_extensive","page":"High-Level Functions","title":"ProgressiveHedging.solve_extensive","text":"solve_extensive(tree::ScenarioTree,\n      subproblem_constructor::Function,\n      optimizer::Function,\n      other_args...;\n      opt_args::NamedTuple=NamedTuple(),\n      subproblem_type::Type{S}=JuMPSubproblem,\n      args::Tuple=(),\n      kwargs...)\n\nSolve given problem using Progressive Hedging.\n\nArguments\n\ntree::ScenararioTree : Scenario tree describing the structure of the problem to be solved.\nsubproblem_constructor::Function : User created function to construct a subproblem. Should accept a ScenarioID (a unique identifier for each scenario subproblem) as an argument and returns a subtype of AbstractSubproblem specified by subproblem_type.\noptimizer::Function : Function which works with JuMP.set_optimizer\nother_args : Other arguments that should be passed to subproblem_constructor. See also keyword arguments args and kwargs\n\nKeyword Arguments\n\nsubproblem_type<:JuMP.AbstractModel : Type of model to create or created by subproblem_constructor to represent the subproblems. Defaults to JuMPSubproblem\nopt_args::NamedTuple : arguments passed to function given by optimizer\nargs::Tuple : Tuple of arguments to pass to model_cosntructor. Defaults to (). See also other_args and kwargs.\nkwargs : Any keyword arguments not specified here that need to be passed to subproblem_constructor.  See also other_args and args.\n\n\n\n\n\n","category":"function"},{"location":"api/types/","page":"Types","title":"Types","text":"CurrentModule = ProgressiveHedging","category":"page"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Exported types in ProgressiveHedging.jl.","category":"page"},{"location":"api/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"api/types/#Callbacks","page":"Types","title":"Callbacks","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Callback\nSubproblemCallback","category":"page"},{"location":"api/types/#ProgressiveHedging.Callback","page":"Types","title":"ProgressiveHedging.Callback","text":"Struct for user callbacks.\n\nFields\n\nname::String : User's name for the callback. Defaults to string(h).\nh::Function : Callback function. See notes below for calling signature.\ninitialize::Function : Function to initialize ext after subproblem creation has occurred.\next::Dict{Symbol,Any} : Dictionary to store data between callback calls or needed parameters.\n\nThe callback function h must have the signature     h(ext::Dict{Symbol,Any}, phd::PHData, winf::WorkerInf, niter::Int)::Bool where ext is the same dictionary given to the Callback constructor, phd is the standard PH data structure (see PHData), winf is used for communicating with subproblems (see apply_to_subproblem)  and niter is the current iteration. The callback may return false to stop PH.\n\nThe initialize function must have the signature     initialize(ext::Dict{Symbol,Any}, phd::PHData) where ext is the same dictionary given to the Callback constructor and phd is the standard PH data structure (see PHData).\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.SubproblemCallback","page":"Types","title":"ProgressiveHedging.SubproblemCallback","text":"Struct for user supbroblem callbacks.\n\nFields\n\nname::String : User's name for the callback. Defaults to string(h).\nh::Function : Callback function. See notes below for calling signature.\next::Dict{Symbol,Any} : Dictionary to store data between callback calls or needed parameters.\n\nThe callback function h must have the signature     h(ext::Dict{Symbol,Any}, sp::T, niter::Int, scenario_id::ScenarioID)  where T <: AbstractSubproblem where ext is the same dictionary given to the Callback constructor, sp is a concrete type of AbstractSubproblem (see AbstractSubproblem), niter is the current iteration and scenario_id is a scenario identifier (see ScenarioID). The callback may return false to stop PH.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Exceptions","page":"Types","title":"Exceptions","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"UnimplementedError","category":"page"},{"location":"api/types/#ProgressiveHedging.UnimplementedError","page":"Types","title":"ProgressiveHedging.UnimplementedError","text":"Exception indicating that the specified method is not implemented for an interface.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ID-Types","page":"Types","title":"ID Types","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"Index\nNodeID\nScenarioID\nStageID\nVariableID\nXhatID","category":"page"},{"location":"api/types/#ProgressiveHedging.Index","page":"Types","title":"ProgressiveHedging.Index","text":"Unique, type-safe identifier for variables associated with the same scenario tree node.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.NodeID","page":"Types","title":"ProgressiveHedging.NodeID","text":"Unique identifier for a ScenarioNode in a ScenarioTree.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.ScenarioID","page":"Types","title":"ProgressiveHedging.ScenarioID","text":"Unique, type-safe identifier for a scenario.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.StageID","page":"Types","title":"ProgressiveHedging.StageID","text":"Unique, type-safe identifier for a stage.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.VariableID","page":"Types","title":"ProgressiveHedging.VariableID","text":"Unique, type-safe identifier for any variable in a (multi-stage) stochastic programming problem.  Composed of a ScenarioID, a StageID and an Index.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.XhatID","page":"Types","title":"ProgressiveHedging.XhatID","text":"Unique identifier for consensus variables. The scenario variables being driven to consensus with this variable is given by convert_to_variable_ids.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Penalty-Parameters","page":"Types","title":"Penalty Parameters","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"ProportionalPenaltyParameter\nScalarPenaltyParameter\nSEPPenaltyParameter","category":"page"},{"location":"api/types/#ProgressiveHedging.ProportionalPenaltyParameter","page":"Types","title":"ProgressiveHedging.ProportionalPenaltyParameter","text":"Variable dependent penalty parameter given by k * c_i where c_i is the linear coefficient of variable i in the objective function.  If c_i == 0 (that is, the variable has no linear coefficient in the objective function), then the penalty value is taken to be k.\n\nwarning: Warning\nThe coefficients in the objective function must match across scenarios. An error will result if they do not.\n\nRequires subproblem type to have implemented report_penalty_info for this type. This implementation should return the linear coefficient in the objective function for each variable.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.ScalarPenaltyParameter","page":"Types","title":"ProgressiveHedging.ScalarPenaltyParameter","text":"Constant scalar penalty parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.SEPPenaltyParameter","page":"Types","title":"ProgressiveHedging.SEPPenaltyParameter","text":"Penalty parameter set with Watson-Woodruff SEP method. See (Watson and Woodruff 2011) for more details.\n\nwarning: Warning\nThe coefficients in the objective function must match across scenarios. An error will result if they do not.\n\nRequires subproblem type to have implemented report_penalty_info for this type. This implementation should return the linear coefficient in the objective function for each variable.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Subproblems","page":"Types","title":"Subproblems","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"JuMPSubproblem","category":"page"},{"location":"api/types/#ProgressiveHedging.JuMPSubproblem","page":"Types","title":"ProgressiveHedging.JuMPSubproblem","text":"Implementation of the AbstractSubproblem interface using JuMP.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#User-Facing","page":"Types","title":"User Facing","text":"","category":"section"},{"location":"api/types/","page":"Types","title":"Types","text":"HatVariable\nPHData\nScenarioNode\nScenarioTree","category":"page"},{"location":"api/types/#ProgressiveHedging.HatVariable","page":"Types","title":"ProgressiveHedging.HatVariable","text":"Type representing a consensus variable.\n\nThe following functions are available to the user to interact with consensus variables\n\nis_integer\nvalue\nvariables\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.PHData","page":"Types","title":"ProgressiveHedging.PHData","text":"Data structure used to store information and results for a stochastic programming problem.\n\nSee the following functions make use of this object:\n\napply_to_subproblem\nbranch_value\nconsensus_variables\nconvert_to_variable_ids\nconvert_to_xhat_id\nget_callback\nget_callback_ext\nis_leaf\nname\nprobability\nscenario_bundle\nscenarios\nstage_id\nvalue\nw_value\nxhat_value\n\nThe following post solution functions are also available:\n\nleaf_value\nretrieve_soln\nretrieve_aug_obj_value\nretrieve_obj_value\nretrieve_no_hats\nretrieve_w\n\nIf the corresponding save options are enabled, the saved terms may be accessed with one of the following:\n\nlower_bounds\nresiduals\nretrieve_xhat_history\nretrieve_no_hat_history\nretrieve_w_history\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.ScenarioNode","page":"Types","title":"ProgressiveHedging.ScenarioNode","text":"Struct representing a node in a scenario tree.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#ProgressiveHedging.ScenarioTree","page":"Types","title":"ProgressiveHedging.ScenarioTree","text":"Struct representing the scenario structure of a stochastic program.\n\nCan be built up by the user using the functions add_node and add_leaf.\n\nConstructor\n\nScenarioTree()\n\nDefault constructor generates the root node of the tree. Can get the root node with root.\n\n\n\n\n\n","category":"type"},{"location":"api/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"api/interfaces/","page":"Interfaces","title":"Interfaces","text":"Pages = [\"interfaces.md\"]","category":"page"},{"location":"api/interfaces/#Penalty-Parameter","page":"Interfaces","title":"Penalty Parameter","text":"","category":"section"},{"location":"api/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractPenaltyParameter\nget_penalty_value\nis_initial_value_dependent\nis_subproblem_dependent\nis_variable_dependent\npenalty_map\nprocess_penalty_initial_value\nprocess_penalty_subproblem","category":"page"},{"location":"api/interfaces/#ProgressiveHedging.AbstractPenaltyParameter","page":"Interfaces","title":"ProgressiveHedging.AbstractPenaltyParameter","text":"Abstract type for ProgressiveHedging penalty parameter.\n\nConcrete subtypes determine how this penalty is used within the PH algorithm.\n\nAll concrete subtypes must implement the following methods:\n\nget_penalty_value(r::<ConcreteSubtype>, xhid::XhatID)::Float64\nis_initial_value_dependent(::Type{<ConcreteSubtype>})::Bool\nis_subproblem_dependent(::Type{<ConcreteSubtype>})::Bool\nis_variable_dependent(::Type{<ConcreateSubtype>})::Bool\n\nIf is_initial_value_dependent returns true, then the concrete subtype must implement\n\nprocess_penalty_initial_value(r::<ConcreteSubtype>, ph_data::PHData)::Nothing\n\nIf is_subproblem_dependent returns true, then the concrete subtype must implement\n\nprocess_penalty_subproblem(r::<ConcreteSubtype>, ph_data::PHData, scenario::ScenarioID, penalties::Dict{VariableID,Float64})::Nothing\n\nAdditionally, the concrete subproblem type must implement the function\n\nreport_penalty_info(as::AbstractSubproblem, pp<:AbstractPenaltyParameter)::Dict{VariableID,Float64}\n\nIf is_variable_dependent returns true, then the concrete subtype must implement\n\npenalty_map(r::<ConcreteSubtype>)::Dict{XhatID,Float64}\n\nIf is_variable_dependent returns false, then the concrete subtype must implement\n\nget_penalty_value(r::<ConcreteSubtype>)::Float64\n\nFor more details, see the help on the individual functions.\n\n\n\n\n\n","category":"type"},{"location":"api/interfaces/#ProgressiveHedging.get_penalty_value","page":"Interfaces","title":"ProgressiveHedging.get_penalty_value","text":"Returns the constant penalty parameter value. Only required if is_variable_dependent returns false.\n\n\n\n\n\nReturns the penalty value for the consensus variable associated with xhid.\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.is_initial_value_dependent","page":"Interfaces","title":"ProgressiveHedging.is_initial_value_dependent","text":"Returns true if the penalty parameter value is dependent on the initial solutions of the subproblems.\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.is_subproblem_dependent","page":"Interfaces","title":"ProgressiveHedging.is_subproblem_dependent","text":"Returns true if the penalty parameter value is dependent on any data or values in the subproblems (e.g., the coefficients in the objective function).\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.is_variable_dependent","page":"Interfaces","title":"ProgressiveHedging.is_variable_dependent","text":"Returns true if the penalty parameter value may differ for different consensus variables.\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.penalty_map","page":"Interfaces","title":"ProgressiveHedging.penalty_map","text":"Returns a mapping of consensus variable ids to penalty parameter values.\n\nOnly required if is_variable_dependent returns false.\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.process_penalty_initial_value","page":"Interfaces","title":"ProgressiveHedging.process_penalty_initial_value","text":"Performs any computations for the penalty parameter based on the initial solutions of the subproblems.\n\nArguments\n\n*r::AbstractPenaltyParameter : penalty parameter struct (replace with appropriate type) *phd::PHData : PH data structure used for obtaining any required variable values. See help on PHData for details on available functions.\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.process_penalty_subproblem","page":"Interfaces","title":"ProgressiveHedging.process_penalty_subproblem","text":"Performs any computations for the penalty parameter based data or values from the subproblems.\n\nThis function is called before the initial solution of subproblems. Any accessing of variable values in this function may result in undefined behavior.\n\nArguments\n\nr::AbstractPenaltyParameter : penalty parameter struct (replace with appropriate type)\nphd::PHData : PH data structure used for obtaining any values or information not provided by scid and subproblem_dict\nscid::ScenarioID : scenario id from which subproblem_dict comes\nsubproblem_dict::Dict{VariableID,Float64} : Mapping specifying a value needed from a subproblem used in the computation of the penalty parameter.\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#Subproblem","page":"Interfaces","title":"Subproblem","text":"","category":"section"},{"location":"api/interfaces/#Types","page":"Interfaces","title":"Types","text":"","category":"section"},{"location":"api/interfaces/","page":"Interfaces","title":"Interfaces","text":"AbstractSubproblem\nVariableInfo","category":"page"},{"location":"api/interfaces/#ProgressiveHedging.AbstractSubproblem","page":"Interfaces","title":"ProgressiveHedging.AbstractSubproblem","text":"Abstract type for ProgressiveHedging subproblem types.\n\nA concrete subtype handles all details of creating, solving and updating subproblems for ProgressiveHedging (PH).  In particular, it handles all interaction with any modeling language that the subproblem is written in.  See JuMPSubproblem for an implementation that uses JuMP as the optimization modeling language.\n\nVariables and their values are identified and exchanged between PH and a Subproblem type using the VariableID type.  A unique VariableID is associated with each variable in the subproblem by the Subproblem implementation by using the ScenarioID of the subproblem as well as the StageID to which this variable belongs.  This combination uniquely identifies a node in the scenario tree to which the variable can be associated.  Variables associated with the same node in a scenario tree and sharing the same name are assumed to be consensus variables whose optimal value is determined by PH.  The final component of a VariableID is an Index which is just a counter assigned to a variable to differentiate it from other variables at the same node.  See VariableID type for more details.\n\nAny concrete subtype must implement the following functions:\n\nadd_ph_objective_terms\nobjective_value\nreport_values\nreport_variable_info\nsolve_subproblem\nupdate_ph_terms\n\nSee help strings on each function for details on arguments, returned objects and expected performance of each function. See JuMPSubproblem for an example using JuMP.\n\nTo use warm_start=true the concrete subtype must also implement\n\nwarm_start\n\nSee help on warm_start for more information.  See JuMPSubproblem for an example using JuMP.\n\nTo use the extensive form functionality, the concrete subtype must implement\n\nef_copy_model\nef_node_dict_constructor\n\nSee the help on the functions for more details. See JuMPSubproblem for an example using JuMP. Note that the extensive form model is always constructed as a JuMP.Model object.\n\nTo use penalty parameter types other than ScalarPenaltyParameter, concrete subproblem types also need to implement\n\nreport_penalty_info\n\nSee the help on individual penalty parameter types and report_penalty_info for more details.\n\nTo use lower bound computation functionality, the concrete subtype must also implement\n\nadd_lagrange_terms\nupdate_lagrange_terms\n\nSee the help on these functions for more details.\n\n\n\n\n\n","category":"type"},{"location":"api/interfaces/#ProgressiveHedging.VariableInfo","page":"Interfaces","title":"ProgressiveHedging.VariableInfo","text":"Struct containing all information needed by PH about a variable (along with the variable id) to run the PH algorithm.\n\nFields\n\nname::String : User specified name of the variable\nis_integer::Bool : True if the variable is an integer or binary\n\n\n\n\n\n","category":"type"},{"location":"api/interfaces/#Required-Functions","page":"Interfaces","title":"Required Functions","text":"","category":"section"},{"location":"api/interfaces/","page":"Interfaces","title":"Interfaces","text":"add_ph_objective_terms\nobjective_value\nreport_values\nreport_variable_info\nsolve_subproblem\nupdate_ph_terms","category":"page"},{"location":"api/interfaces/#ProgressiveHedging.add_ph_objective_terms","page":"Interfaces","title":"ProgressiveHedging.add_ph_objective_terms","text":"add_ph_objective_terms(as::AbstractSubproblem,\n                       vids::Vector{VariableID},\n                       r::Union{Float64,Dict{VariableID,Float64}}\n                       )::Dict{VariableID,Float64}\n\nCreate model variables for Lagrange multipliers and hat variables and add Lagrange and proximal terms to the objective function.\n\nReturns mapping of the variable to any information needed from the subproblem to compute the penalty parameter. Only used if is_subproblem_dependent(typeof(r)) returns true.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\nvids::Vector{VariableID} : list of VariableIDs which need ph terms created\nr::AbstractPenaltyParameter : penalty parameter on quadratic term\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.objective_value","page":"Interfaces","title":"ProgressiveHedging.objective_value","text":"objective_value(as::AbstractSubproblem)::Float64\n\nReturn the objective value of the solved subproblem.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.report_values","page":"Interfaces","title":"ProgressiveHedging.report_values","text":"report_values(as::AbstractSubproblem,\n              vars::Vector{VariableID}\n              )::Dict{VariableID, Float64}\n\nReturn the variable values specified by vars.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\nvars::Vector{VariableID} : collection of VariableIDs to gather values for\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.report_variable_info","page":"Interfaces","title":"ProgressiveHedging.report_variable_info","text":"report_variable_info(as::AbstractSubproblem,\n                     st::ScenarioTree\n                     )::Dict{VariableID, VariableInfo}\n\nAssign VariableIDs to all model variables and build a map from those ids to the required variable information (e.g., variable name).  See VariableInfo help for details on required variable information.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\nst::ScenarioTree : scenario tree for the entire PH problem\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.solve_subproblem","page":"Interfaces","title":"ProgressiveHedging.solve_subproblem","text":"solve_subproblem(as::AbstractSubproblem)::MOI.TerminationStatusCode\n\nSolve the subproblem specified by as and return the status code.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.update_ph_terms","page":"Interfaces","title":"ProgressiveHedging.update_ph_terms","text":"update_ph_terms(as::AbstractSubproblem,\n                w_vals::Dict{VariableID,Float64},\n                xhat_vals::Dict{VariableID,Float64}\n                )::Nothing\n\nUpdate the values of the PH variables in this subproblem with those given by w_vals and xhat_vals.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\nw_vals::Dict{VariableID,Float64} : Values to update Lagrangian variables with\nxhat_vals::Dict{VariableID,Float64} : Values to update proximal variables with\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#Optional-Functions","page":"Interfaces","title":"Optional Functions","text":"","category":"section"},{"location":"api/interfaces/","page":"Interfaces","title":"Interfaces","text":"warm_start","category":"page"},{"location":"api/interfaces/#ProgressiveHedging.warm_start","page":"Interfaces","title":"ProgressiveHedging.warm_start","text":"warm_start(as::AbstractSubproblem)::Nothing\n\nUse the values of previous solves non-PH variables as starting points of the next solve.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#Extensive-Form-Functions","page":"Interfaces","title":"Extensive Form Functions","text":"","category":"section"},{"location":"api/interfaces/","page":"Interfaces","title":"Interfaces","text":"ef_copy_model\nef_node_dict_constructor","category":"page"},{"location":"api/interfaces/#ProgressiveHedging.ef_copy_model","page":"Interfaces","title":"ProgressiveHedging.ef_copy_model","text":"ef_copy_model(destination::JuMP.Model,\n              original::AbstractSubproblem,\n              scid::ScenarioID,\n              scen_tree::ScenarioTree,\n              node_dict::Dict{NodeID, Any}\n              )\n\nCopy the subproblem described by original to the extensive form model destination.\n\nArguments\n\ndestination::JuMP.Model : extensive form of the model that is being built\noriginal::AbstractSubproblem : subproblem object (replace with appropriate type)\nscid::ScenarioID : ScenarioID corresponding to this subproblem\nscen_tree::ScenarioTree : scenario tree for the entire PH problem\nnode_dict::Dict{NodeID, Any} : dictionary for transferring nodal information from one submodel to another\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.ef_node_dict_constructor","page":"Interfaces","title":"ProgressiveHedging.ef_node_dict_constructor","text":"ef_node_dict_constructor(::Type{S}) where S <: AbstractSubproblem\n\nConstruct dictionary that is used to carry information between subproblems for ef_copy_model.\n\nArguments\n\n::Type{S} : Subproblem type\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#Penalty-Parameter-Functions","page":"Interfaces","title":"Penalty Parameter Functions","text":"","category":"section"},{"location":"api/interfaces/","page":"Interfaces","title":"Interfaces","text":"report_penalty_info","category":"page"},{"location":"api/interfaces/#ProgressiveHedging.report_penalty_info","page":"Interfaces","title":"ProgressiveHedging.report_penalty_info","text":"report_penalty_info(as::AbstractSubproblem,\n                    pp<:AbstractPenaltyParameter,\n                    )::Dict{VariableID,Float64}\n\nReturns mapping of variable to a value used to compute the penalty parameter.\n\nThis function must be implemented for any concrete penalty parameter type for which is_subproblem_dependent returns true and any concrete subproblem type wishing to use that penalty parameter. The mapping must contain all subproblem values needed for processing by process_penalty_subproblem. The returned mapping is handed unaltered to process_penalty_subproblem as the subproblem_dict argument.\n\nArguments\n\n*as::AbstractSubproblem : subproblem object (replace with appropriate type) *pp<:AbstractPenaltyParameter : penalty parameter type\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#Lower-Bound-Functions","page":"Interfaces","title":"Lower Bound Functions","text":"","category":"section"},{"location":"api/interfaces/","page":"Interfaces","title":"Interfaces","text":"add_lagrange_terms\nupdate_lagrange_terms","category":"page"},{"location":"api/interfaces/#ProgressiveHedging.add_lagrange_terms","page":"Interfaces","title":"ProgressiveHedging.add_lagrange_terms","text":"add_lagrange_terms(as::AbstractSubproblem,\n                   vids::Vector{VariableID}\n                   )::Nothing\n\nCreate model variables for Lagrange multipliers and adds the corresponding terms to the objective function.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\nvids::Vector{VariableID} : list of VariableIDs which need Lagrange terms\n\nSee also add_ph_objective_terms.\n\n\n\n\n\n","category":"function"},{"location":"api/interfaces/#ProgressiveHedging.update_lagrange_terms","page":"Interfaces","title":"ProgressiveHedging.update_lagrange_terms","text":"update_lagrange_terms(as::AbstractSubproblem,\n                      w_vals::Dict{VariableID,Float64}\n                      )::Nothing\n\nUpdate the values of the dual variables in this subproblem with those given by w_vals.\n\nArguments\n\nas::AbstractSubproblem : subproblem object (replace with appropriate type)\nw_vals::Dict{VariableID,Float64} : values to update Lagrange dual variables with\n\nSee also update_ph_terms.\n\n\n\n\n\n","category":"function"},{"location":"examples/callback/#Callback-Example","page":"Callback Example","title":"Callback Example","text":"","category":"section"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"An example of creating and adding a callback to a ProgressiveHedging.jl run. This example is also available as the script callback_example.jl in the example directory.","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"In this example, we will use the same setup as in the Basic Example.","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"using ProgressiveHedging\nimport JuMP\nimport Ipopt\n\nfunction two_stage_model(scenario_id::ScenarioID)\n\n    model = JuMP.Model(()->Ipopt.Optimizer())\n    JuMP.set_optimizer_attribute(model, \"print_level\", 0)\n    JuMP.set_optimizer_attribute(model, \"tol\", 1e-12)\n    JuMP.set_optimizer_attribute(model, \"acceptable_tol\", 1e-12)\n\n    scen = value(scenario_id)\n\n    ref = JuMP.@variable(model, x >= 0.0)\n    stage1 = [ref]\n\n    ref = JuMP.@variable(model, y >= 0.0)\n    stage2 = [ref]\n\n    b_s = scen == 0 ? 11.0 : 4.0\n    c_s = scen == 0 ? 0.5 : 10.0\n\n    JuMP.@constraint(model, x + y == b_s)\n\n    JuMP.@objective(model, Min, 1.0*x + c_s*y)\n\n    return JuMPSubproblem(model,\n                          scenario_id,\n                          Dict(stid(1) => stage1,\n                               stid(2) => stage2)\n                          )\nend\n\nscen_tree = two_stage_tree(2)\nnothing # hide","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"We now write a function to get called as PH executes and wrap it in the Callback type.","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"function my_callback(ext::Dict{Symbol,Any},\n                     phd::PHData,\n                     winf::ProgressiveHedging.WorkerInf,\n                     niter::Int)\n    # The `ext` dictionary can be used to store things between PH iterations\n    if niter == 2\n        ext[:message] = \"This is from iteration 2!\"\n    elseif niter == 5\n        println(\"Iteration 5 found the message: \" * ext[:message])\n    elseif niter == 10\n        println(\"This is iteration 10!\")\n        # We can access the current consensus variable values\n        for (xhid, xhat) in pairs(consensus_variables(phd))\n            println(\"The value of $(name(phd,xhid)) is $(value(xhat)).\")\n        end\n    end\n    # Returning false from the callback will terminate PH.\n    # Here we stop after 20 iterations.\n    return niter < 20\nend\n\nmy_cb = Callback(my_callback)\nnothing # hide","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"Several things are worth noting here:","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"All callback functions must have the signature given here\nThe ext dictionary is unique to each callback and can be used to pass information from one iteration to the next\nReturning false from the callback will terminate PH","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"Now we call the solve function as before but giving it the callback object we created.","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"(niter, abs_res, rel_res, obj, soln_df, phd) = solve(scen_tree,\n                                                     two_stage_model,\n                                                     ScalarPenaltyParameter(1.0),\n                                                     callbacks=[my_cb]\n                                                     )\n@show niter\n@show abs_res\n@show rel_res\n@show obj\n@show soln_df\nnothing # hide","category":"page"},{"location":"examples/callback/","page":"Callback Example","title":"Callback Example","text":"The callbacks can be used to implement solution heuristics and alternative termination criteria.  There are two callbacks are included with ProgressiveHedging.jl that do this.  variable_fixing is a heuristic that fixes variables whose values remain (approximately) the same over a set number of iterations. It is hoped that this speeds the convergence of PH. mean_deviation is an alternative termination criteria. It is a form of mean relative absolute deviation from the consensus variable value. These are both implmentations of ideas found in (Watson & Woodruff 2010).","category":"page"},{"location":"examples/distributed/#Distributed-Example","page":"Distributed Example","title":"Distributed Example","text":"","category":"section"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"An example of how to enable distributed computation within ProgressiveHedging.jl. This example is also available as the script distributed_example.jl in the example directory.","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"Our first step here is to setup the worker processes. To do this we will use the Julia native Distributed package.","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"using Distributed\naddprocs(2) # add 2 workers","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"Now we need to setup the environment as before but the worker processes need to load the packages too. However, the worker processes are in the default julia environment when launched. If the necessary packages are not installed in this environment, or you want to use a different environment, you'll nee to explicitly activate it for the workers. Here we will activate the examples environment. Activating the proper environment on each worker can be done first by loading Pkg on every worker using the @everywhere macro and then using Pkg.activate to actually activate the environment.","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"@everywhere using Pkg\n@everywhere Pkg.activate(joinpath(@__DIR__, \"..\", \"examples\"))","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"Finally, we again use the Distributed package's @everywhere macro to load the needed packages.","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"@everywhere using ProgressiveHedging\n@everywhere import JuMP\n@everywhere import Ipopt","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"Just as in every other case we define the function that is used to create a subproblem. In this case, however, we need to make sure that the worker processes are aware of the function. We once more do this with the @everywhere macro.","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"@everywhere function two_stage_model(scenario_id::ScenarioID)\n\n    model = JuMP.Model(()->Ipopt.Optimizer())\n    JuMP.set_optimizer_attribute(model, \"print_level\", 0)\n    JuMP.set_optimizer_attribute(model, \"tol\", 1e-12)\n    JuMP.set_optimizer_attribute(model, \"acceptable_tol\", 1e-12)\n\n    scen = value(scenario_id)\n\n    ref = JuMP.@variable(model, x >= 0.0)\n    stage1 = [ref]\n\n    ref = JuMP.@variable(model, y >= 0.0)\n    stage2 = [ref]\n\n    b_s = scen == 0 ? 11.0 : 4.0\n\tc_s = scen == 0 ? 0.5 : 10.0\n\n    JuMP.@constraint(model, x + y == b_s)\n\n    JuMP.@objective(model, Min, 1.0*x + c_s*y)\n\n    return JuMPSubproblem(model,\n                          scenario_id,\n                          Dict(stid(1) => stage1,\n                               stid(2) => stage2)\n                          )\nend","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"Now we proceed just as before. Create the scenario tree and call the solve function. This is all done locally. The rest of the computation distribution will be handled by PH.","category":"page"},{"location":"examples/distributed/","page":"Distributed Example","title":"Distributed Example","text":"scen_tree = two_stage_tree(2)\n\n(niter, abs_res, rel_res, obj, soln_df, phd) = solve(scen_tree,\n                                                     two_stage_model,\n                                                     ScalarPenaltyParameter(1.0)\n                                                     )\n@show niter\n@show abs_res\n@show rel_res\n@show obj\n@show soln_df","category":"page"},{"location":"examples/multi-stage/#Multi-Stage-Example","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"","category":"section"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"An example of solving a multi-stage problem with ProgressiveHedging.jl. This example is also available as the script multistage_example.jl in the examples directory.","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"Using PH to solve a multi-stage problem is very similar to a two-stage problem. The only significant difference is in the creation of the scenario tree.","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"We will create a three-stage problem. First we import the proper packages and define the subproblem creation function","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"using ProgressiveHedging\nimport JuMP\nimport Ipopt\n\nfunction create_model(scenario_id::ScenarioID)\n    \n    model = JuMP.Model(()->Ipopt.Optimizer())\n    JuMP.set_optimizer_attribute(model, \"print_level\", 0)\n    JuMP.set_optimizer_attribute(model, \"tol\", 1e-12)\n    \n    c = [1.0, 10.0, 0.01]\n    d = 7.0\n    a = 16.0\n\n    α = 1.0\n    β = 1.0\n    γ = 1.0\n    δ = 1.0\n    ϵ = 1.0\n\n    s1 = 8.0\n    s2 = 4.0\n    s11 = 9.0\n    s12 = 16.0\n    s21 = 5.0\n    s22 = 18.0\n    \n    stage1 = JuMP.@variable(model, x[1:3] >= 0.0)\n    JuMP.@constraint(model, x[3] <= 1.0)\n    obj = zero(JuMP.GenericQuadExpr{Float64,JuMP.VariableRef})\n    JuMP.add_to_expression!(obj, sum(c.*x))\n\n    # Second stage\n    stage2 = Vector{JuMP.VariableRef}()\n    if scenario_id < scid(2)\n        vref = JuMP.@variable(model, y >= 0.0)\n        JuMP.@constraint(model, α*sum(x) + β*y >= s1)\n        JuMP.add_to_expression!(obj, d*y)\n    else\n        vref = JuMP.@variable(model, y >= 0.0)\n        JuMP.@constraint(model, α*sum(x) + β*y >= s2)\n        JuMP.add_to_expression!(obj, d*y)\n    end\n    push!(stage2, vref)\n\n    # Third stage\n    stage3 = Vector{JuMP.VariableRef}()\n    if scenario_id == scid(0)\n        vref = JuMP.@variable(model, z[1:2])\n        JuMP.@constraint(model, ϵ*sum(x) + γ*y + δ*sum(z) == s11)\n        JuMP.add_to_expression!(obj, a*sum(z[i]^2 for i in 1:2))\n        \n    elseif scenario_id == scid(1)\n        vref = JuMP.@variable(model, z[1:2])\n        JuMP.@constraint(model, ϵ*sum(x) + γ*y + δ*sum(z) == s12)\n        JuMP.add_to_expression!(obj, a*sum(z[i]^2 for i in 1:2))\n\n    elseif scenario_id == scid(2)\n        vref = JuMP.@variable(model, z[1:2])\n        JuMP.@constraint(model, ϵ*sum(x) + γ*y + δ*sum(z) == s21)\n        JuMP.add_to_expression!(obj, a*sum(z[i]^2 for i in 1:2))\n\n    else\n        vref = JuMP.@variable(model, z[1:2])\n        JuMP.@constraint(model, ϵ*sum(x) + γ*y + δ*sum(z) == s22)\n        JuMP.add_to_expression!(obj, a*sum(z[i]^2 for i in 1:2))\n    end\n    append!(stage3, vref)\n\n    JuMP.@objective(model, Min, obj)\n    \n    vdict = Dict{StageID, Vector{JuMP.VariableRef}}([stid(1) => stage1,\n                                                     stid(2) => stage2,\n                                                     stid(3) => stage3,\n                                                     ])\n    \n    return JuMPSubproblem(model, scenario_id, vdict)\nend\nnothing # hide","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"Now we create the scenario tree with two branch nodes in the second stage.","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"scen_tree = ScenarioTree()\nbranch_node_1 = add_node(scen_tree, root(scen_tree))\nbranch_node_2 = add_node(scen_tree, root(scen_tree))","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"To each branch node, we add two leaf nodes","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"add_leaf(scen_tree, branch_node_1, 0.375)\nadd_leaf(scen_tree, branch_node_1, 0.125)\n\nadd_leaf(scen_tree, branch_node_2, 0.375)\nadd_leaf(scen_tree, branch_node_2, 0.125)\nnothing # hide","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"Finally, we solve just as we normally would","category":"page"},{"location":"examples/multi-stage/","page":"Multi-Stage Example","title":"Multi-Stage Example","text":"(niter, abs_res, rel_res, obj, soln_df, phd) = solve(scen_tree,\n                                                     create_model,\n                                                     ScalarPenaltyParameter(25.0);\n                                                     atol=1e-8, rtol=1e-12, max_iter=500)\n@show niter\n@show abs_res\n@show rel_res\n@show obj\n@show soln_df\nnothing # hide","category":"page"},{"location":"#ProgressiveHedging.jl","page":"Overview","title":"ProgressiveHedging.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = ProgressiveHedging","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ProgressiveHedging.jl is a Julia implementation of the Progressive Hedging algorithm of Rockafellar and Wets.  It is capable of solving multi-stage stochastic programs:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"min_X sum_s=1^S p_s f_s(X)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"To solve this problem, ProgressiveHedging.jl makes use of JuMP. Specifically, the user constructs a wrapped JuMP model for a single subproblem as well as a scenario tree which describes the structure of the stochastic program. For more details on the process see this Basic Example. Through the use of Julia's Distributed package, PH may be run in parallel either on a single multi-core platform or in a distributed fashion across multiple compute nodes. See the Distributed Example for more details.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"In addition to providing an easily accessible solver for stochastic programs, ProgressiveHedging.jl is designed to be extensible to enable research on the PH algorithm itself.  Abstract interfaces exist for the penalty parameter and subproblem types so that the user may implement their own penalty parameter selection method or use an Julia enabled algebraic modeling language.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"ProgressiveHedging has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL)","category":"page"},{"location":"examples/basic/#Basic-Example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"examples/basic/#Problem","page":"Basic Example","title":"Problem","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"A basic example using ProgressiveHedging.jl to solve a stochastic program. This example is also available as the script basic_example.jl in the example directory.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Here we will use ProgressiveHedging.jl to solve the simple problem","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"min_x x + sum_s=0^1 p_s c_s y_s","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"subject to","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"x ge 0","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"y_s ge 0 s in 01","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"x + y = b_s","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"where","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"b_s = begincases 11  s=0  4  s=1 endcases","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"c_s = begincases 05  s=0  10  s=1 endcases","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"and for now we will take equally probable scenarios, that is, p_0 = p_1 = 05.","category":"page"},{"location":"examples/basic/#Setup","page":"Basic Example","title":"Setup","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"First we need to bring in the needed packages","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"using ProgressiveHedging\nimport JuMP\nimport Ipopt","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We will need JuMP to build the model for each subproblem and we will use Ipopt to solve each subproblem.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"note: Note\nThere are some functions that both JuMP and ProgressiveHedging export. To avoid confusion (and warnings) it is best to import one or both of these packages.","category":"page"},{"location":"examples/basic/#Subproblem-Creation-Function","page":"Basic Example","title":"Subproblem Creation Function","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Next, we write a function that will generate the subproblems for each scenario. The following creates the subproblem for a simple two stage stochastic program.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"function two_stage_model(scenario_id::ScenarioID)\n\n    model = JuMP.Model(()->Ipopt.Optimizer())\n    JuMP.set_optimizer_attribute(model, \"print_level\", 0)\n    JuMP.set_optimizer_attribute(model, \"tol\", 1e-12)\n    JuMP.set_optimizer_attribute(model, \"acceptable_tol\", 1e-12)\n\n    scen = value(scenario_id)\n\n    ref = JuMP.@variable(model, x >= 0.0)\n    stage1 = [ref]\n\n    ref = JuMP.@variable(model, y >= 0.0)\n    stage2 = [ref]\n\n    b_s = scen == 0 ? 11.0 : 4.0\n\tc_s = scen == 0 ? 0.5 : 10.0\n\n    JuMP.@constraint(model, x + y == b_s)\n\n    JuMP.@objective(model, Min, 1.0*x + c_s*y)\n\n    return JuMPSubproblem(model,\n                          scenario_id,\n                          Dict(stid(1) => stage1,\n                               stid(2) => stage2)\n                          )\nend\nnothing # hide","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"There are a few things to note here:","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"This function must take as an argument a ScenarioID.\nThe mathematical model is built using JuMP.\nThe function returns a JuMPSubproblem. This is an implementation of the AbstractSubproblem interface which uses JuMP as the algebraic modeling language.\nIn addition to the model, the subproblem also requires the ScenarioID and a dictionary identifying which variables belong in which stage.","category":"page"},{"location":"examples/basic/#Scenario-Tree-Construction","page":"Basic Example","title":"Scenario Tree Construction","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Second we need to construct a ScenarioTree that captures the structure of our stochastic program. We can do this using the ScenarioTree constructor and the function add_leaf:","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"scen_tree = ScenarioTree()\nscenario_id_0 = add_leaf(scen_tree, root(scen_tree), 0.5)\nscenario_id_1 = add_leaf(scen_tree, root(scen_tree), 0.5)\nnothing # hide","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Here we created a scenario tree and added two leaf nodes each representing the two scenarios in our problem. We specified both occur with probability 0.5. The other thing to note is that add_leaf returns a ScenarioID. This is a type-safe integer that PH uses to uniquely indentify the each scenario and subproblem. Note that the numbering starts at 0.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"@show scenario_id_0\n@show scenario_id_1\nnothing # hide","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"The subproblem created by the subproblem creation function should correspond to the path in the scenario tree that leads to this leaf. In our case, we have a two-stage tree and it does not matter which scenario is identified as scenario 0 and scenario 1.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"Since two-stage stochastic programs are extremely common, ProgressiveHedging.jl provides a convenience function to generate two-stage trees with arbitrarily many scenarios: two_stage_tree. So we could have used","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"using ProgressiveHedging # hide\nscen_tree = two_stage_tree(2)\nnothing # hide","category":"page"},{"location":"examples/basic/#Solution","page":"Basic Example","title":"Solution","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"We are now ready to solve the problem. To do so we just use the solve function and provide it with our scenario tree, the subproblem creation function and a penalty parameter.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"# Hack to avoid having the Ipopt inclusion message in the documentation...\n(niter, abs_res, rel_res, obj, soln_df, phd) = solve(scen_tree,\n                                                     two_stage_model,\n                                                     ScalarPenaltyParameter(1.0)\n                                                     )","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"(niter, abs_res, rel_res, obj, soln_df, phd) = solve(scen_tree,\n                                                     two_stage_model,\n                                                     ScalarPenaltyParameter(1.0)\n                                                     )\n@show niter\n@show abs_res\n@show rel_res\n@show obj\n@show soln_df\nnothing # hide","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"The solve function returns the number of iteration, the absolute and relative residual, the objective value, a DataFrame containing the solution and, lastly, a PHData instance.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"The PHData contains additional information like the dual (Lagrange multiplier) values for the nonanticipativity constraints","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"dual_df = retrieve_w(phd)\n@show dual_df\nnothing # hide","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"as well as the raw values of the consensus contributing variables","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"raw_values_df = retrieve_no_hats(phd)\n@show raw_values_df\nnothing # hide","category":"page"},{"location":"examples/basic/#Determining-the-Consensus-Variables","page":"Basic Example","title":"Determining the Consensus Variables","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"note: Determining the Consensus Variables\nYou may notice that we never specifically indicated which variables needed nonanticipativity constraints. ProgressiveHedging determines this automatically for us using the scenario tree we constructed, the stage the variable is in and the name the variable is given. When using the JuMPSubproblem, the name of the variable is determined by calling the function JuMP.name on each JuMP.VariableRef object. The stage is given by the dictionary given to the JuMPSubproblem constructor as seen in the subproblem creation function above. This is possible because the combination of a ScenarioID and a StageID uniquely determine a node on the scenario tree. Any variables with the same names that belong to this node are assumed to require nonanticipativity constraints and so are identified as consensus variables.","category":"page"},{"location":"examples/basic/#Extensive-Solve","page":"Basic Example","title":"Extensive Solve","text":"","category":"section"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"For smaller problems, it is also possible to solve the extensive form of the problem directly. ProgressiveHedging.jl is capable of building the extensive form from the previously defined function and scenario tree.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"ef_model = solve_extensive(scen_tree,\n                           two_stage_model,\n                           ()->Ipopt.Optimizer(),\n                           opt_args=(print_level=0, tol=1e-12, acceptable_tol=1e-12)\n                           )\n\nnothing # hide","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"This function builds, optimizes and returns a JuMP model of the extensive form. As such, information is obtained from it as from any other JuMP model.","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"@show JuMP.termination_status(ef_model)\n@show JuMP.objective_value(ef_model)\nfor v in JuMP.all_variables(ef_model)\n    println(\"$v = $(JuMP.value(v))\")\nend\nnothing # hide","category":"page"},{"location":"examples/basic/","page":"Basic Example","title":"Basic Example","text":"note: Note\nThe subscripts in the variable names are the scenarios to which the variable belongs.","category":"page"},{"location":"api/functions/#Low-Level-Functions","page":"Low-Level Functions","title":"Low-Level Functions","text":"","category":"section"},{"location":"api/functions/","page":"Low-Level Functions","title":"Low-Level Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"api/functions/#Callback-Creation-and-Retrieval","page":"Low-Level Functions","title":"Callback Creation and Retrieval","text":"","category":"section"},{"location":"api/functions/","page":"Low-Level Functions","title":"Low-Level Functions","text":"apply_to_subproblem\ncb\nget_callback\nget_callback_ext\nmean_deviation\nspcb\nvariable_fixing","category":"page"},{"location":"api/functions/#ProgressiveHedging.apply_to_subproblem","page":"Low-Level Functions","title":"ProgressiveHedging.apply_to_subproblem","text":"apply_to_subproblem(to_apply::Function,\n                    phd::PHData,\n                    winf::WorkerInf,\n                    scid::ScenarioID,\n                    args::Tuple=(),\n                    kwargs::NamedTuple=NamedTuple(),\n                    )\n\nApplies the function to_apply to the subproblem with scenario id scid.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.cb","page":"Low-Level Functions","title":"ProgressiveHedging.cb","text":"cb(f::Function)\ncb(f::Function, ext::Dict{Symbol,Any})\ncb(f::Function, initialize::Function)\ncb(f::Function, initialize::Function, ext::Dict{Symbol,Any})\ncb(name::String, f::Function, ext::Dict{Symbol,Any})\n\nShorthand for Callback functions with the same signature.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.get_callback","page":"Low-Level Functions","title":"ProgressiveHedging.get_callback","text":"get_callback(phd::PHData, name::String)::Callback\n\nRetrieve the callback with name name.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.get_callback_ext","page":"Low-Level Functions","title":"ProgressiveHedging.get_callback_ext","text":"get_callback_ext(phd::PHData, name::String)::Dict{Symbol,Any}\n\nRetrieve the external dictionary for callback name.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.mean_deviation","page":"Low-Level Functions","title":"ProgressiveHedging.mean_deviation","text":"mean_deviation(;tol::Float64=1e-8,\n               save_deviations::Bool=false\n               )::Callback\n\nImplementation of a termination criterion given in section 2.3 of (Watson & Woodruff 2010). There it is called 'td'.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.spcb","page":"Low-Level Functions","title":"ProgressiveHedging.spcb","text":"spcb(f::Function)\n\nShorthand for SubproblemCallback(f).\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.variable_fixing","page":"Low-Level Functions","title":"ProgressiveHedging.variable_fixing","text":"variable_fixing(; lag=2, eq_tol=1e-8)::Callback\n\nImplementation of the variable fixing convergence acceleration heuristic in section 2.2 of (Watson & Woodruff 2010).\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ID-Type-Interactions","page":"Low-Level Functions","title":"ID Type Interactions","text":"","category":"section"},{"location":"api/functions/","page":"Low-Level Functions","title":"Low-Level Functions","text":"convert_to_variable_ids\nconvert_to_xhat_id\nindex\nscenario\nscid\nstage\nstage_id\nstid\nvalue(::Index)\nvalue(::NodeID)\nvalue(::ScenarioID)\nvalue(::StageID)","category":"page"},{"location":"api/functions/#ProgressiveHedging.convert_to_variable_ids","page":"Low-Level Functions","title":"ProgressiveHedging.convert_to_variable_ids","text":"convert_to_variable_ids(phd::PHData, xid::XhatID)::Set{VariableID}\n\nConvert the given consensus variable id to the contributing individual subproblem variable ids.\n\nArguments\n\nphd::PHData : PH data structure for the corresponding problem\nxid::XhatID : consensus variable id to convert\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.convert_to_xhat_id","page":"Low-Level Functions","title":"ProgressiveHedging.convert_to_xhat_id","text":"convert_to_xhat_id(phd::PHData, vid::VariableID)::XhatID\n\nConvert the given VariableID to the consensus variable id (XhatID).\n\nArguments\n\nphd::PHData : PH data structure for the corresponding problem\nvid::VariableID : variable id to convert\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.index","page":"Low-Level Functions","title":"ProgressiveHedging.index","text":"index(vid::VariableID)::Index\n\nReturns the Index of the specified VariableID.\n\n\n\n\n\nindex(n::Int64)::Index\n\nCreate Index from n.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.scenario","page":"Low-Level Functions","title":"ProgressiveHedging.scenario","text":"scenario(vid::VariableID)::ScenarioID\n\nReturns the ScenarioID of the specified VariableID.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.scid","page":"Low-Level Functions","title":"ProgressiveHedging.scid","text":"scid(n::Int64)::ScenarioID\n\nCreate ScenarioID from n.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.stage","page":"Low-Level Functions","title":"ProgressiveHedging.stage","text":"stage(vid::VariableID)::StageID\n\nReturns the StageID of the specified VariableID.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.stage_id","page":"Low-Level Functions","title":"ProgressiveHedging.stage_id","text":"stage_id(phd::PHData, xid::XhatID)::StageID\n\nReturns the StageID in which the given consensus variable is.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.stid","page":"Low-Level Functions","title":"ProgressiveHedging.stid","text":"stid(n::Int64)::StageID\n\nCreate StageID from n.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.value-Tuple{Index}","page":"Low-Level Functions","title":"ProgressiveHedging.value","text":"value(idx::Index)\n\nReturn the raw (non-type safe) value of an Index\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#ProgressiveHedging.value-Tuple{NodeID}","page":"Low-Level Functions","title":"ProgressiveHedging.value","text":"value(nid::NodeID)\n\nReturn the raw (non-type safe) value of a NodeID\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#ProgressiveHedging.value-Tuple{ScenarioID}","page":"Low-Level Functions","title":"ProgressiveHedging.value","text":"value(scid::ScenarioID)\n\nReturn the raw (non-type safe) value of a ScenarioID\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#ProgressiveHedging.value-Tuple{StageID}","page":"Low-Level Functions","title":"ProgressiveHedging.value","text":"value(stid::StageID)\n\nReturn the raw (non-type safe) value of a StageID\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#Result-Retrieval","page":"Low-Level Functions","title":"Result Retrieval","text":"","category":"section"},{"location":"api/functions/","page":"Low-Level Functions","title":"Low-Level Functions","text":"lower_bounds\nprint_timing\nresiduals\nretrieve_soln\nretrieve_aug_obj_value\nretrieve_obj_value\nretrieve_no_hats\nretrieve_no_hat_history\nretrieve_w\nretrieve_w_history\nretrieve_xhat_history","category":"page"},{"location":"api/functions/#ProgressiveHedging.lower_bounds","page":"Low-Level Functions","title":"ProgressiveHedging.lower_bounds","text":"lower_bounds(phd::PHData)::DataFrames.DataFrame\n\nReturn a DataFrame with the computed and saved lower bounds. See the lower_bound keyword argument on solve.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.print_timing","page":"Low-Level Functions","title":"ProgressiveHedging.print_timing","text":"print_timing(phd::PHData)\n\nPrints timining information from the Progressive Hedging solve.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.residuals","page":"Low-Level Functions","title":"ProgressiveHedging.residuals","text":"residuals(phd::PHData)::DataFrames.DataFrame\n\nReturn a DataFrame with absolute and relative residuals along with the components. See the save_residuals keyword argument on solve.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.retrieve_soln","page":"Low-Level Functions","title":"ProgressiveHedging.retrieve_soln","text":"retrieve_soln(phd::PHData)::DataFrames.DataFrame\n\nReturn a DataFrame with the solution values of all consensus and leaf variables.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.retrieve_aug_obj_value","page":"Low-Level Functions","title":"ProgressiveHedging.retrieve_aug_obj_value","text":"retrieve_aug_obj_value(phd::PHData)::Float64\n\nReturn the current objective value including Lagrange and proximal PH terms of the stochastic program.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.retrieve_obj_value","page":"Low-Level Functions","title":"ProgressiveHedging.retrieve_obj_value","text":"retrieve_obj_value(phd::PHData)::Float64\n\nReturn the current objective value without Lagrange and proximal PH terms.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.retrieve_no_hats","page":"Low-Level Functions","title":"ProgressiveHedging.retrieve_no_hats","text":"retrieve_no_hats(phd::PHData)::DataFrames.DataFrame\n\nReturn a DataFrame with the final nonconsensus variable values.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.retrieve_no_hat_history","page":"Low-Level Functions","title":"ProgressiveHedging.retrieve_no_hat_history","text":"retrieve_no_hat_history(phd::PHData)::DataFrames.DataFrame\n\nReturn a DataFrame with the saved nonconsensus variable values. See the save_iterates keyword argument on solve.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.retrieve_w","page":"Low-Level Functions","title":"ProgressiveHedging.retrieve_w","text":"retrieve_w(phd::PHData)::DataFrames.DataFrame\n\nReturn a DataFrame with the final anticipativity constraint Lagrange multiplier values.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.retrieve_w_history","page":"Low-Level Functions","title":"ProgressiveHedging.retrieve_w_history","text":"retrieve_w_history(phd::PHData)::DataFrames.DataFrame\n\nReturn a DataFrame with the saved PH Lagrange variable values. See the save_iterates keyword argument on solve.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.retrieve_xhat_history","page":"Low-Level Functions","title":"ProgressiveHedging.retrieve_xhat_history","text":"retrieve_xhat_history(phd::PHData)::DataFrames.DataFrame\n\nReturn a DataFrame with the saved consensus variable values. See the save_iterates keyword argument on solve.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Problem-Accessors","page":"Low-Level Functions","title":"Problem Accessors","text":"","category":"section"},{"location":"api/functions/","page":"Low-Level Functions","title":"Low-Level Functions","text":"probability\nscenario_tree\nscenarios","category":"page"},{"location":"api/functions/#ProgressiveHedging.probability","page":"Low-Level Functions","title":"ProgressiveHedging.probability","text":"probability(phd::PHData, scenario::ScenarioID)::Float64\n\nReturns the probability of the given scenario.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.scenario_tree","page":"Low-Level Functions","title":"ProgressiveHedging.scenario_tree","text":"scenario_tree(phd::PHData)::ScenarioTree\n\nReturns the scenario tree for created stochastic programming problem.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.scenarios","page":"Low-Level Functions","title":"ProgressiveHedging.scenarios","text":"scenarios(phd::PHData)::Set{ScenarioID}\n\nReturns the set of all scenarios for the stochastic problem.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Scenario-Tree","page":"Low-Level Functions","title":"Scenario Tree","text":"","category":"section"},{"location":"api/functions/","page":"Low-Level Functions","title":"Low-Level Functions","text":"add_node\nadd_leaf\nroot\ntwo_stage_tree","category":"page"},{"location":"api/functions/#ProgressiveHedging.add_node","page":"Low-Level Functions","title":"ProgressiveHedging.add_node","text":"add_node(tree::ScenarioTree, parent::ScenarioNode)\n\nAdd a node to the ScenarioTree tree with parent node parent. Return the added node. If the node to add is a leaf, use add_leaf instead.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.add_leaf","page":"Low-Level Functions","title":"ProgressiveHedging.add_leaf","text":"add_leaf(tree::ScenarioTree, parent::ScenarioNode, probability<:Real)\n\nAdd a leaf to the ScenarioTree tree with parent node parent. The probability of this scenario occuring is given by probability. Returns the ScenarioID representing the scenario.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.root","page":"Low-Level Functions","title":"ProgressiveHedging.root","text":"root(tree::ScenarioTree)\n\nReturn the root node of the given ScenarioTree\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.two_stage_tree","page":"Low-Level Functions","title":"ProgressiveHedging.two_stage_tree","text":"two_stage_tree(n::Int)::ScenarioTree\ntwo_stage_tree(p::Vector{R})::ScenarioTree where R <: Real\n\nConstruct and return a two-stage scenario tree with n scenarios with equal probability or a two-stage scenario tree with length(p) scenarios where probability of scenario s is p[s+1].\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#Variable-Interactions","page":"Low-Level Functions","title":"Variable Interactions","text":"","category":"section"},{"location":"api/functions/","page":"Low-Level Functions","title":"Low-Level Functions","text":"branch_value\nconsensus_variables\nis_integer\nis_leaf\nleaf_value\nname\nscenario_bundle\nvalue(::HatVariable)\nvalue(::PHData, ::VariableID)\nvalue(::PHData, ::ScenarioID, ::StageID, ::Index)\nvariables\nw_value\nxhat_value","category":"page"},{"location":"api/functions/#ProgressiveHedging.branch_value","page":"Low-Level Functions","title":"ProgressiveHedging.branch_value","text":"branch_value(phd::PHData, vid::VariableID)::Float64\n\nReturns the value of the variable associated with vid. Must be a branch variable.\n\nSee also: leaf_value, value\n\n\n\n\n\nbranch_value(phd::PHData, scen::ScenarioID, stage::StageID, idx::Index)::Float64\n\nReturns the value of the variable associated with with scenario scen, stage stage and index idx. Must be a branch variable.\n\nSee also: leaf_value, value\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.consensus_variables","page":"Low-Level Functions","title":"ProgressiveHedging.consensus_variables","text":"consensus_variables(phd::PHData)::Dict{XhatID,HatVariable}\n\nReturns the collection of consensus variables for the problem.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.is_integer","page":"Low-Level Functions","title":"ProgressiveHedging.is_integer","text":"is_integer(a::HatVariable)::Bool\n\nReturns true if the consensus variable is an integer variable. The consensus variable is an integer if the contributing subproblem variables are all integer variables.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.is_leaf","page":"Low-Level Functions","title":"ProgressiveHedging.is_leaf","text":"is_leaf(phd::PHData, xhid::XhatID)::Bool\n\nReturns true if the given consensus variable id belongs to a leaf vertex in the scenario tree.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.leaf_value","page":"Low-Level Functions","title":"ProgressiveHedging.leaf_value","text":"leaf_value(phd::PHData, vid::VariableID)::Float64\nleaf_value(phd::PHData, scen::ScenarioID, stage::StageID, idx::Index)::Float64\n\nReturns the value of the variable associated with vid or with scenario scen, stage stage and index idx. Must be a leaf variable.\n\nWARNING: For computational efficiency, leaf values are collected only at the end of a PH run. Therefore, using this function in a callback will result in an error.\n\nSee also: branch_value, value\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.name","page":"Low-Level Functions","title":"ProgressiveHedging.name","text":"name(phd::PHData, vid::VariableID)::String\n\nReturns the name of the consensus variable for the given VariableID.\n\n\n\n\n\nname(phd::PHData, xid::XhatID)::String\n\nReturns the name of the consensus variable for the given XhatID. The name is the same given to the individual scenario variables.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.scenario_bundle","page":"Low-Level Functions","title":"ProgressiveHedging.scenario_bundle","text":"scenario_bundle(phd::PHData, xid::XhatID)::Set{ScenarioID}\n\nReturns the scenarios contributing to the consensus variable associated with xid.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.value-Tuple{HatVariable}","page":"Low-Level Functions","title":"ProgressiveHedging.value","text":"value(a::HatVariable)::Float64\n\nReturns the current value of a.\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#ProgressiveHedging.value-Tuple{PHData, VariableID}","page":"Low-Level Functions","title":"ProgressiveHedging.value","text":"value(phd::PHData, vid::VariableID)\n\nReturns the value of the variable associated with vid.\n\nSee also: branch_value, leaf_value\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#ProgressiveHedging.value-Tuple{PHData, ScenarioID, StageID, Index}","page":"Low-Level Functions","title":"ProgressiveHedging.value","text":"value(phd::PHData, scen::ScenarioID, stage::StageID, idx::Index)::Float64\n\nReturns the value of the variable associated with scenario scen, stage stage and index idx.\n\nSee also: branch_value, leaf_value\n\n\n\n\n\n","category":"method"},{"location":"api/functions/#ProgressiveHedging.variables","page":"Low-Level Functions","title":"ProgressiveHedging.variables","text":"variables(a::HatVariable)::Set{VariableID}\n\nReturns the variable ids for all subproblem variables contributing to this variable.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.w_value","page":"Low-Level Functions","title":"ProgressiveHedging.w_value","text":"w_value(phd::PHData, vid::VariableID)\n\nReturns the value of the variable associated with vid. Only available for branch variables.\n\n\n\n\n\nw_value(phd::PHData, scen::ScenarioID, stage::StageID, idx::Index)::Float64\n\nReturns the value of the variable associated with scenario scen, stage stage and index idx. Only available for branch variables.\n\n\n\n\n\n","category":"function"},{"location":"api/functions/#ProgressiveHedging.xhat_value","page":"Low-Level Functions","title":"ProgressiveHedging.xhat_value","text":"xhat_value(phd::PHData, xhid::VariableID)::Float64\n\nReturns the value of the consensus variable associated with xhid. Only available for leaf variables after calling solve.  Available for branch variables at any time.\n\n\n\n\n\nxhat_value(phd::PHData, vid::VariableID)::Float64\n\nReturns the value of the consensus variable associated with vid. Only available for leaf variables after calling solve.  Available for branch variables at any time.\n\n\n\n\n\nxhat_value(phd::PHData, scen::ScenarioID, stage::StageID, idx::Index)::Float64\n\nReturns the value of the consensus variable associated with scenario scen, stage stage and index idx. Only available for leaf variables after calling solve.  Available for branch variables at any time.\n\n\n\n\n\n","category":"function"}]
}
